package org.iplantc.service.jobs.managers.monitors.parsers;

import org.iplantc.service.jobs.model.Job;
import org.iplantc.service.jobs.model.enumerations.JobStatusType;

import java.util.ArrayList;
import java.util.List;

/**
 * LoadLeveler job status codes and mappings to Agave {@link JobStatusType} values.
 * Status codes taken from: https://www.ibm.com/support/knowledgecenter/SSFJTW_5.1.0/com.ibm.cluster.loadl.v5r1.load100.doc/am2ug_jobstate.htm
 * TODO: Verify correct mappings to active and queued statuses.
 */
public enum LoadLevelerJobStatus implements RemoteSchedulerJobStatus<LoadLevelerJobStatus> {

	// queued
	DEFERRED("D", "The job will not be assigned to a machine until a specified date. This date may have been specified by the user in the job command file, or may have been generated by the negotiator because a parallel job did not accumulate enough machines to run the job. (Only the negotiator places a job in the Deferred state.)", JobStatusType.QUEUED),
	USER_HOLD("H", "The job has been put in user hold.", JobStatusType.QUEUED),
	SYSTEM_HOLD("S", "The job has been put in system hold.", JobStatusType.QUEUED),
	USER_HOLD_SYSTEM_HOLD("HS", "The job has been put in system hold and user hold.", JobStatusType.QUEUED),
	IDLE("I", "The job is being considered to run on a machine, though no machine has been selected.", JobStatusType.QUEUED),
	VACATED("V", "The job started but did not complete. The negotiator will reschedule the job (provided the job is allowed to be rescheduled). Possible reasons why a job moves to the Vacate state are: the machine where the job was running was flushed, the VACATE expression in the configuration file evaluated to True, or LoadLeveler detected a condition indicating the job needed to be vacated.", JobStatusType.QUEUED),
	VACATE_PENDING("VP", "The job has been vacated and in process of being queued.", JobStatusType.QUEUED),

	// failed
	REJECTED("X", "The job was rejected.", null),
	REJECT_PENDING("XP", "The job did not start. Possible reasons why a job is rejected are: job requirements were not met on the target machine, or the user ID of the person running the job is not valid on the target machine. After a job leaves the Reject Pending state, it is moved into one of the following states: Idle, User Hold, or Removed.", null),

	// running
	STARTING("ST", "The job is starting: the job was dispatched, was received by the target machine, and LoadLeveler is setting up the environment in which to run the job. For a parallel job, LoadLeveler sets up the environment on all required nodes. See the description of the \"Pending\" state for more information on when the negotiator or the schedd daemon moves a job into the Starting state.", JobStatusType.RUNNING),
	RUNNING("R", "The job is running: the job was dispatched and has started on the designated machine.", JobStatusType.RUNNING),
	REMOVE_PENDING("RP", "The job is in the process of being removed, but not all associated machines have acknowledged the removal of the job.", JobStatusType.RUNNING),
	PENDING("P", "The job is in the process of starting on one or more machines.", JobStatusType.RUNNING),
	COMPLETE_PENDING("CP", "The job has completed and awaiting formal updating", JobStatusType.RUNNING),
	CHECKPOINTING("CK", "A checkpoint has been initiated.", JobStatusType.RUNNING),
	TERMINATED("TX", "The job was terminated and will be deleted or rescheduled if policy allows.", JobStatusType.RUNNING),

	// done
	COMPLETED("C", "The job has completed.", null),
	CANCELLED("CA", "The job has been cancelled.", null),

	// failed
	REMOVED("RM", "The job was removed (cancelled), either by LoadLeveler or by the user.", null),
	NOT_RUN("NR", "The job will never be run because a dependency associated with the job was found to be false.", null),
	NOT_QUEUED("NQ", "The job is not being considered to run on a machine. A job can enter this state because the associated schedd is down, the user or group associated with the job is at its maximum maxqueued or maxidle value, or because the job has a dependency which cannot be determined. ", null),
	SUBMISSION_ERROR("SX", "The job was rejected due to a submission error.", null),

	UNKNOWN("", "Job status is unknown or could not be obtained.", null);

	private String description;
	private String code;
	private JobStatusType mappedJobStatusType;

	LoadLevelerJobStatus(String code, String description, JobStatusType mappedJobStatusType) {
		this.setDescription(description);
		this.setCode(code);
		this.setMappedJobStatusType(mappedJobStatusType);
	}

	/**
	 * @return the description
	 */
	public String getDescription() {
		return description;
	}

	/**
	 * @param description the description to set
	 */
	public void setDescription(String description) {
		this.description = description;
	}

	/**
	 * @return the code
	 */
	public String getCode() {
		return code;
	}

	/**
	 * @param code the code to set
	 */
	public void setCode(String code) {
		this.code = code;
	}

	@Override
	public String toString() {
		return name() + " - " + getDescription();
	}

	/**
	 * Active statuses indicate that the job is in some sort of non-terminal state and has not been
	 * interrupted or placed in a paused or suspended state.
	 *
	 * @return list of {@link LoadLevelerJobStatus} associated with an active job status
	 */
	@Override
	public List<LoadLevelerJobStatus> getActiveStatuses() {
		ArrayList<LoadLevelerJobStatus> activeStatuses = new ArrayList<LoadLevelerJobStatus>(getQueuedStatuses());
		activeStatuses.addAll(getRunningStatuses());

		return activeStatuses;
	}

	/**
	 * Queued statuses indicate that the job currently waiting to run in the remote scheduler's queue.
	 *
	 * @return list of {@link LoadLevelerJobStatus} associated with an queued job status
	 */
	@Override
	public List<LoadLevelerJobStatus> getQueuedStatuses() {
		return List.of(DEFERRED, IDLE, SYSTEM_HOLD, USER_HOLD, USER_HOLD_SYSTEM_HOLD, VACATED, VACATE_PENDING);
	}

	/**
	 * Running statuses indicate that the job is currently running, or in process of setting up, running,
	 * or cleaning up on the remote system. This phase of the lifecycle is completely handled by the
	 * scheduler and does not overlap with {@link JobStatusType} at all.
	 *
	 * @return list of {@link LoadLevelerJobStatus} associated with an running job status
	 */
	@Override
	public List<LoadLevelerJobStatus> getRunningStatuses() {
		return List.of(CHECKPOINTING, COMPLETE_PENDING, PENDING, REMOVE_PENDING, RUNNING, STARTING, TERMINATED);
	}

	/**
	 * Returns whether this {@link LoadLevelerJobStatus} is the unknown type. This usually happens when a job is no longer
	 * available for query from the remote scheduler's queue listing due to the job being archived, or rotated out of
	 * the queue listing after completion. For HPC jobs, this usually means further queries should be made to decipher
	 * the exit code, etc of the job.
	 *
	 * @return true if the status is unknown, false otherwise.
	 */
	@Override
	public List<LoadLevelerJobStatus> getUnknownStatuses() {
		return List.of(UNKNOWN);
	}

	/**
	 * Failed statuses indicate that the job failed to run to completion in some way. It may have been killed,
	 * pre-empted, cancelled by a user, had a node fail, etc.
	 *
	 * @return list of {@link LoadLevelerJobStatus} associated with an active job status
	 */
	@Override
	public List<LoadLevelerJobStatus> getFailedStatuses() {
		return List.of(REMOVED, REJECT_PENDING, REJECTED, NOT_RUN, NOT_QUEUED, SUBMISSION_ERROR);
	}

	/**
	 * Unrecoverable statuses indicate that something went horribly wrong on the remote system and the scheduler
	 * has given up on not only running the job, but in any way cleaning up after it. These jobs can be suck in
	 * this state indefinitely without intervention from an administrator. Agave treats this as a failure and
	 * moves on from the job once detected.
	 *
	 * @return list of {@link LoadLevelerJobStatus} associated with an active job status
	 */
	@Override
	public List<LoadLevelerJobStatus> getUnrecoverableStatuses() {
		return List.of();
	}

	/**
	 * Paused statuses indicate that the job has been placed in a susupended state, but not cancelled, after
	 * being in a running state. This does not map to Agave functionality, but instead reflects the remote
	 * scheduler functionality. The behavior of the scheduler and code upon returning to a running state
	 * is not guaranteed.
	 *
	 * @return list of {@link LoadLevelerJobStatus} associated with an active job status
	 */
	@Override
	public List<LoadLevelerJobStatus> getPausedStatuses() {
		return List.of();
	}

	/**
	 * Indicates whether the status represents a running state on the remote system. This includes cleanup, teardown,
	 * staging, etc. on the remote scheduler. These statuses are all independent of Agave's {@link JobStatusType}
	 * statuses and are simply used to determine when to move the {@link Job} into the {@link JobStatusType#RUNNING}
	 * state.
	 *
	 * @return true if the status is in {@link #getActiveStatuses()}, false otherwise
	 * @throws IllegalArgumentException if the {@code satus} value is empty or not a known SlurmStatusType enumerated value.
	 * @see #getActiveStatuses()
	 */
	@Override
	public boolean isActiveStatus() {
		return getActiveStatuses().contains(this);
	}

	/**
	 * Returns whether this {@link LoadLevelerJobStatus} is a completed state. Completed includes all statues that
	 * are not active or unknown.
	 *
	 * @return false if the job is active or unknown, true otherwise.
	 * @see #getActiveStatuses()
	 * @see #getUnknownStatuses()
	 */
	public boolean isDoneStatus() {
		return !isActiveStatus() && !isUnknownStatus() && !isPausedStatus();
	}

	/**
	 * Returns whether this {@link LoadLevelerJobStatus} represents a failure state of the remote job. This includes
	 * suspended jobs and jobs in transition states.
	 *
	 * @return true if the status is in {@link #getFailedStatuses()}, false otherwise
	 * @see #getFailedStatuses()
	 */
	@Override
	public boolean isFailureStatus() {
		return getFailedStatuses().contains(this);
	}

	/**
	 * Returns whether this {@link LoadLevelerJobStatus} is a paused state. Paused jobs may be restarted in the
	 * future if the scheudler supports it. No guarantee is made to the availbility of this feature, this
	 * method simply reflects the scheduler's reporting that the job has been paused, usually by an administrator.
	 *
	 * @return true if the status is in {@link #getPausedStatuses()}, false otherwise
	 * @see #getPausedStatuses()
	 */
	@Override
	public boolean isPausedStatus() {
		return getPausedStatuses().contains(this);
	}

	/**
	 * Returns whether this {@link LoadLevelerJobStatus}  is an unrecoverable state. This happens when the job is
	 * This includes suspended jobs.
	 *
	 * @return true if the status is in {@link #getUnrecoverableStatuses()}, false otherwise
	 * @see #getUnrecoverableStatuses()
	 */
	@Override
	public boolean isUnrecoverableStatus() {
		return getUnrecoverableStatuses().contains(this);
	}

	/**
	 * Returns whether this {@link LoadLevelerJobStatus}  is the unknown type. This usually happens when a job is no longer
	 * available for query from the remote scheduler's queue listing due to the job being archived, or rotated out of
	 * the queue listing after completion. For HPC jobs, this usually means further queries should be made to decipher
	 * the exit code, etc of the job.
	 *
	 * @return true if the status is in {@link #getUnknownStatuses()}, false otherwise
	 */
	@Override
	public boolean isUnknownStatus() {
		return getUnknownStatuses().contains(this);
	}

	/**
	 * Returns whether this {@link LoadLevelerJobStatus} is an queued state. Queued includes held jobs in queue.
	 *
	 * @return true if the status is in {@link #getQueuedStatuses()}, false otherwise
	 */
	@Override
	public boolean isQueuedStatus() {
		return getQueuedStatuses().contains(this);
	}

	/**
	 * Returns whether this {@link LoadLevelerJobStatus} is a running state. Running varies from scheduler to scheduler
	 * based on the way it handles job startup, cleanup, and even reporting.
	 *
	 * @return true if the status is in {@link #getRunningStatuses()}, false otherwise
	 */
	public boolean isRunningStatus() {
		return getRunningStatuses().contains(this);
	}

	/**
	 * Each remote scheduler job status is mapped to a {@link JobStatusType}. This method returns the mapped value
	 * corresponding to this {@link RemoteSchedulerJobStatus}.
	 *
	 * @return the {@link JobStatusType} corresponding to the scheduler status.
	 */
	@Override
	public JobStatusType getMappedJobStatusType() {
		return mappedJobStatusType;
	}

	/**
	 * @param mappedJobStatusType the mappedJobStatusType to set
	 */
	private void setMappedJobStatusType(JobStatusType mappedJobStatusType) {
		this.mappedJobStatusType = mappedJobStatusType;
	}

	/**
	 * Returns the {@link LoadLevelerJobStatus} with code matching the value passed in regardless of case.
	 * This is similar to valueOf, but provides an {@link LoadLevelerJobStatus#UNKNOWN} value when
	 * no codes match.
	 * @param code the status code to match in a case-insensitive way.
	 * @return the {@link LoadLevelerJobStatus} with matching code, or {@link LoadLevelerJobStatus#UNKNOWN} if no matches.
	 */
	public static LoadLevelerJobStatus valueOfCode(String code) {
		for(LoadLevelerJobStatus status: values()) {
			if (status.code.equalsIgnoreCase(code)) {
				return status;
			}
		}

		return UNKNOWN;
	}
}