node ('master') {

    env.JAVA_HOME="${tool 'openjdk-9'}"
    env.MVN_HOME="${tool 'maven-3.6.3'}"
    env.PATH="${env.JAVA_HOME}/bin:${env.MVN_HOME}/bin:${env.PATH}"
	env.BUILD_IMAGE="agaveplatform/maven:3.6.3-proto"

	env.DOCKER_REGISTRY_URL = ''
	env.DOCKER_REGISTRY_ORG = 'agaveplatform'
	env.GIT_BRANCH = '2.2.27'


	// Send a message indicating the start of the build. We record the thread and add it to the environment
	// so we thread all future messages
    def slackResponse = slackSend(color: "good", message: "Started Agave Science API build <${env.JOB_DISPLAY_URL}|${env.BUILD_DISPLAY_NAME}>")
    env.SLACK_THREAD_ID=slackResponse.threadId

    checkoutSource()
    // build()
    // unitTest()
    // integrationTest()
    // buildAndPublishDockerImages()
    helmDeploy()

    helmTest()

    slackSend channel: slackResponse.threadId, color: "green", message: "CI/CD pipeline completed successfully. Logs are available <${env.RUN_DISPLAY_URL}|here>"
}

def isPRMergeBuild() {
    return (env.BRANCH_NAME ==~ /^PR-\d+$/)
}

// Returs the short commit hash for the current checkout. We use this approach to avoid compatibility issues with the
// response from the GitSCM plugin
//
// @returns short 7 digit git commit hash
def shortCommitHash() {
	return sh(returnStdout: true, script: "git log -n 1 --pretty=format:'%h'").trim()
}

// Returns the full commit hash for the current checkout. We use this approach to avoid compatibility issues with the
// response from the GitSCM plugin
//
// @returns full git commit hash
def commitHash() {
	return sh(returnStdout: true, script: "git rev-parse HEAD").trim()
}


def checkoutSource () {
    stage('Checkout code') {
		try {
			context="continuous-integration/jenkins/"
			context += isPRMergeBuild()?"pr-merge/checkout":"branch/checkout"
			checkout([$class: 'GitSCM',
					branches: [[name: "*/${env.GIT_BRANCH}"]],
					doGenerateSubmoduleConfigurations: false,
					extensions: [],
					submoduleCfg: [],
					userRemoteConfigs: [
						[credentialsId: 'deardooley-github-access-token',
						url: 'https://deardooley@github.com/agaveplatform/science-apis.git']]])
			//    setBuildStatus ("${context}", 'Checking out completed', 'SUCCESS')


			// set the commit hash and short hash for use in this build
			env.GIT_COMMIT=commitHash()
			env.GIT_SHORT_HASH=shortCommitHash()

			slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Checked out commit ${env.GIT_SHORT_HASH} from branch ${env.GIT_BRANCH}."
		} catch (err) {
			slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Source checkout failed. Logs are available <${env.RUN_DISPLAY_URL}|here>."
			throw err
		}
	}
}

def build () {
    stage('Build Source') {
		//def MAVEN_CMD = "/usr/bin/docker run -i --rm -w $(pwd) -v ${env.WORKSPACE}:${env.WORKSPACE} -v ${env.HOME}/.m2:/root/.m2  -v /var/run/docker.sock:/var/run/docker.sock --net host agaveplatform/maven:3.6.3-proto mvn -Dstyle.color=never "
        def MAVEN_CMD = "mvn -Dstyle.color=never "
		try {
			sh "${MAVEN_CMD} -T 1.0C -P agave,dev clean compile "
			slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Source compilation complete."
		}
		catch (err) {
			slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Source compilation failed. Logs are available <${env.RUN_DISPLAY_URL}|here>."
			throw err
		}
	}
}

def unitTest() {
	stage ('Unit Tests') {
		//def MAVEN_CMD = "/usr/bin/docker run -i --rm -w ${env.WORKSPACE} -v ${env.WORKSPACE}:${env.WORKSPACE} -v ${env.HOME}/.m2:/root/.m2  -v /var/run/docker.sock:/var/run/docker.sock --net=host agaveplatform/maven:3.6.3-proto mvn -Dstyle.color=never "
		def MAVEN_CMD = "mvn -Dstyle.color=never "

		try {
			sh "${MAVEN_CMD} -T 1.0C -P agave,dev install"

			// collect unit test output for report and archiving
			step([$class: 'JUnitResultArchiver', testResults: '**/target/surefire-reports/TEST-*.xml'])

			slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Unit tests completed successfully. Test results available <${env.RUN_TESTS_DISPLAY_URL}|here>."
		}
		catch (err) {
			slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Unit tests failed. Test results available <${env.RUN_TESTS_DISPLAY_URL}|here>."
			throw err
		}
	}
}

def integrationTest() {
	stage ('Integration Tests') {
        withCredentials([usernamePassword(credentialsId: 'docker-hub-login', passwordVariable: 'DOCKER_REGISTRY_PASS', usernameVariable: 'DOCKER_REGISTRY_USER')]) {
			//def MAVEN_CMD = "/usr/bin/docker run -i --rm -w ${env.WORKSPACE} -v ${env.WORKSPACE}:${env.WORKSPACE} -v ${env.HOME}/.m2:/root/.m2 -v ${env.HOME}/.docker:/root/.docker -v /usr/bin/docker:/usr/bin/docker -v /var/run/docker.sock:/var/run/docker.sock --net=host agaveplatform/maven:3.6.3-proto mvn -Dstyle.color=never "
            def MAVEN_CMD = "mvn -Dstyle.color=never -P agave,integration-test verify -Dawait-maven-plugin.initialWait=15000 -Ddocker-compose-plugin.awaitDuration=10 -Dskip.post-integration.pause=false "

			try {
				// login to the docker registry
    			sh "docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_PASS} ${env.DOCKER_REGISTRY_URL}"

                stage ('Migrations') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl agave-migrations "
                }

                stage ('Protobuf Java Stubs') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :protos-java "
                }

                stage ('sftp-relay') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :sftp-relay "
                }

                stage ('Common Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :common-core "
                }

                stage ('Common API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :common-api "
                }

                stage ('Common Legacy API') {
                    clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :common-legacy-api "
                }

                stage ('Postits API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :postits-api "
                }

                stage ('Usage API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :usage-api "
                	clearCurrentContainers()
                }

                stage ('Tenants API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :tenants-api "
                }

                stage ('Logging API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :logging-api "
                }

                stage ('Notifications Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :notifications-core "
                }

                stage ('Notifications API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :notifications-api "
                }

                stage ('Profiles Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :profiles-core "
                }

                stage ('Profiles API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :profiles-api "
                }

                stage ('Metadata Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :metadata-core "
                }

                stage ('Metadata API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :metadata-api "
                }

                stage ('Systems Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :systems-core "
                }

                stage ('Systems API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :systems-api "
                	clearCurrentContainers()
                }

                stage ('Monitors Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :monitors-core "
                	clearCurrentContainers()
                }

                stage ('Monitors API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :monitors-api "
                	clearCurrentContainers()
                }

                stage ('Files Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :files-core "
                	clearCurrentContainers()
                }

                stage ('Files API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :files-api "
                }

                stage ('Apps Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :apps-core "
                }

                stage ('Apps API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :apps-api "
                }

                stage ('Jobs Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :jobs-core "
                }

                stage ('Jobs API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :jobs-api "
                }

                stage ('Tags Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :tags-core "
                }

                stage ('Tags API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :tags-api "
                }

                stage ('Realtime Core') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :realtime-core "
                }

                stage ('Realtime API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :realtime-api "
                }

                stage ('Stats API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :stats-api "
                }

                stage ('Uuids API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :uuids-api "
                }

                stage ('Apidocs API') {
                	clearCurrentContainers()
                	sh "${MAVEN_CMD} -pl :apidocs-api "
                }

    			step([$class: 'JUnitResultArchiver', testResults: '**/target/failsafe-reports/TEST-*.xml'])

    			slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Integration tests completed successfully. Test results available <${env.RUN_TESTS_DISPLAY_URL}|here>."

			}
			catch (err) {

				clearCurrentContainers()

				slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Integration tests failed.  Test results available <${env.RUN_TESTS_DISPLAY_URL}|here>."

				throw err
			}

		}
	}
}

// Remove existing containers to avoid conflicts from failed builds
def clearCurrentContainers() {

    echo "Stopping existing docker containers"

	sh "docker ps -a --format '{{.Names}}' | grep -v traefik_traefik_  | xargs --no-run-if-empty docker stop"

	echo "Removing existing containers"

	sh "docker ps -a --format '{{.Names}}' | grep -v traefik_traefik_  | xargs --no-run-if-empty docker rm -f"
}

// Runs all local and 3rd party integration tests with code coverage anaalysis enabled.
def coverage() {
    stage ('Code Coverage Analysis') {
		withCredentials([file(credentialsId: 'maven-third-party-settings-file', variable: 'MAVEN_THIRD_PARTY_SETTINGS_FILE'),
						 usernamePassword(credentialsId: 'docker-hub-login', passwordVariable: 'DOCKER_REGISTRY_PASS', usernameVariable: 'DOCKER_REGISTRY_USER')]) {

            //def MAVEN_CMD = "docker run -i --rm -v ${env.MAVEN_THIRD_PARTY_SETTINGS_FILE}:/root/settings.xml -v ${env.WORKSPACE}:/sources -v ${env.HOME}/.m2:/root/.m2  -v /usr/bin/docker:/usr/bin/docker -v /var/run/docker.sock:/var/run/docker.sock --net=host agaveplatform/maven:3.6.3-proto mvn --settings=/root/settings.xml"
            def MAVEN_CMD = "mvn -Dstyle.color=never --settings=${env.MAVEN_THIRD_PARTY_SETTINGS_FILE} "
			try {
			    // login to the docker registry
			    sh "docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_PASS} ${env.DOCKER_REGISTRY_URL}"

				sh "${MAVEN_CMD} -P agave,integration-test,coverage verify"
				step( [$class: 'JacocoPublisher', exclusionPattern: '**/*Exception*,**/*Configuration*,**/ApiApplication*,**/*Test*'])
			}
			catch (err) {
				slackSend color: "red", message: "Failed running coverage analysis. Logs are available <${env.RUN_DISPLAY_URL}|here>."
				throw err
			}
		}
	}
}

// handles clean build and push of docker images for the current branch and revision
def buildAndPublishDockerImages() {
    clearImages()
    buildImages()
    pushImages()
}

// clears out existing revision and branch images
def clearImages() {
    stage ("Clean Docker Images") {
    	try {
    	    // remove local branch images
			sh "./dockerbuild.sh -c -t localdev -v ${env.GIT_BRANCH}"
			// remove existing revision images
			sh "./dockerbuild.sh -c -t ${env.DOCKER_REGISTRY_ORG} -v ${env.GIT_SHORT_HASH}"
			// remove existing branch images
			sh "./dockerbuild.sh -c -t ${env.DOCKER_REGISTRY_ORG} -v ${env.GIT_BRANCH}"
            // remove existing dev branch images
			sh "./dockerbuild.sh -c -t ${env.DOCKER_REGISTRY_ORG} -v ${env.GIT_BRANCH}-dev"

			slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Docker image cleanup completed successfully."
		} catch (err) {
			slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Docker image cleanup failed. Logs are available <${env.RUN_DISPLAY_URL}|here>."
			throw err
		}
	}
}

// builds new images tagged with the short revision commit hash and the branch name
def buildImages() {
    stage ("Build Docker Images") {
		// load docker credentials so we don't get bitten by the docker registry rate limiting policy
		withCredentials([usernamePassword(credentialsId: 'docker-hub-login', passwordVariable: 'DOCKER_REGISTRY_PASS', usernameVariable: 'DOCKER_REGISTRY_USER')]) {
			try {
				// login to the docker registry
				sh "docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_PASS} ${env.DOCKER_REGISTRY_URL}"

				// build images from current revision
				sh "./dockerbuild.sh -b -t localdev -v ${env.GIT_BRANCH}"

				// tag local branch build with dev branch repo and name
                sh "./dockerbuild.sh -r -s localdev -w ${env.GIT_BRANCH} -t ${env.DOCKER_REGISTRY_ORG} -v ${env.GIT_BRANCH}-dev"

				// tag local branch build with revision images
				sh "./dockerbuild.sh -r -s localdev -w ${env.GIT_BRANCH} -t ${env.DOCKER_REGISTRY_ORG} -v ${env.GIT_SHORT_HASH}"

				slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Docker build completed successfully. Log available <${env.BUILD_URL}|here>."
			} catch (err) {
				slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Docker build failed. Logs are available <${env.RUN_DISPLAY_URL}|here>."
				throw err
			}
		}
	}
}

// push images to the configured docker registry
def pushImages() {
	stage('Push Docker Images') {
		withCredentials([usernamePassword(credentialsId: 'docker-hub-login', passwordVariable: 'DOCKER_REGISTRY_PASS', usernameVariable: 'DOCKER_REGISTRY_USER')]) {
			try {
				// login to the docker registry
				sh "docker login -u ${DOCKER_REGISTRY_USER} -p ${DOCKER_REGISTRY_PASS} ${env.DOCKER_REGISTRY_URL}"
				// push revision images to repo
				sh "./dockerbuild.sh -p -t ${env.DOCKER_REGISTRY_ORG} -v ${env.GIT_SHORT_HASH}"
				// push branch images to repo
				sh "./dockerbuild.sh -p -t ${env.DOCKER_REGISTRY_ORG} -v ${env.GIT_BRANCH}-dev"

				slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Docker image push to ${env.DOCKER_REGISTRY_URL} completed successfully."
			} catch (err) {
				slackSend channel: env.SLACK_THREAD_ID, color: "danger", message: "Docker image push failed. Logs are available <${env.RUN_DISPLAY_URL}|here>."
				throw err
			}
		}
	}
}

def helmDeploy() {
	stage('Deploy Helm Chart') {
		withCredentials([file(credentialsId: 'agave-kubectl-config', variable: 'KUBECONFIG_FILE')]) {
			try {
				def branchSubdomain = env.GIT_BRANCH.replaceAll('\\.','-')

				sh("helm repo add agave https://helm.agaveplatform.org")

				sh("helm repo update")

				sh("rm -rf helm")

				sh("mkdir -p helm")

				sh("helm fetch agave/core-services --destination ./helm --untar")

				sh("helm package ./helm/core-services --destination ./helm --dependency-update --app-version=${env.GIT_SHORT_HASH} --namespace=${branchSubdomain}")

				def packagedChartVersion = sh(returnStdout: true, script: "/bin/bash -c 'helm show chart helm/core-services | ${env.HOME}/.local/bin/yq -r .version'").trim()

				sh("helm --kubeconfig \"${KUBECONFIG_FILE}\" upgrade --install --namespace=${branchSubdomain} core-services helm/core-services-${packagedChartVersion}.tgz  --create-namespace  --set global.tenantBaseUrl=${branchSubdomain}.dev.k8s.agaveplatform.org,global.baseUrl=core-${branchSubdomain}.dev.k8s.agaveplatform.org,global.agaveVersion=${env.GIT_SHORT_HASH}")

				slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Helm deployment completed successfully. Core services will be available at <https://core-${branchSubdomain}.dev.k8s.agaveplatform.org|https://${branchSubdomain}.dev.k8s.agaveplatform.org>."
			} catch (err) {
				slackSend channel: env.SLACK_THREAD_ID, color: "danger", "Helm deployment failed. Logs are available <${env.RUN_DISPLAY_URL}|here>."
				throw err
			}
// 			finally {
// 			  sh ("rm -rf ./helm")
// 			}
      	}
  	}
}

def helmTest() {
	stage('Helm Chart Tests') {
		withCredentials([file(credentialsId: 'agave-kubectl-config', variable: 'KUBECONFIG_FILE')]) {
			try {
				def branchSubdomain = env.GIT_BRANCH.replaceAll('\\.','-')
				waitUntil {
					def pendingPods = sh(returnStdout: true, script: "/bin/bash -c 'kubectl --kubeconfig=\"${KUBECONFIG_FILE}\" -n ${branchSubdomain} get pods -o json | jq -r '.items[].status.phase' | grep -v Running | grep -v Succeeded").trim();
					return (pendingPods == null || pendingPods == '')
				}

				// now run tests
				sh("helm --kubeconfig \"${KUBECONFIG_FILE}\" test core-services --namespace=${branchSubdomain} --logs --timeout=30m0s")

				slackSend channel: env.SLACK_THREAD_ID, color: "green", message: "Helm tests completed successfully. Deployment is ready for use at <https://core-${branchSubdomain}.dev.k8s.agaveplatform.org|https://core-${branchSubdomain}.dev.k8s.agaveplatform.org>."
			} catch (err) {
				slackSend channel: env.SLACK_THREAD_ID, color: "danger", "Helm tests failed. Logs are available <${env.RUN_DISPLAY_URL}|here>."
				throw err
			}
		}
	}
}

// def preProduction() {
//     switchSnapshotBuildToRelease()
//     herokuApp = "${env.HEROKU_PREPRODUCTION}"
//     deployToStage("preproduction", herokuApp)
//     buildAndPublishToArtifactory()
// }
//
// def manualPromotion() {
//   stage 'Manual Promotion'
//     // we need a first milestone step so that all jobs entering this stage are tracked an can be aborted if needed
//     milestone 1
//     // time out manual approval after ten minutes
//     timeout(time: 10, unit: 'MINUTES') {
//         input message: "Does Pre-Production look good?"
//     }
//     // this will kill any job which is still in the input step
//     milestone 2
// }

// def production() {
//     herokuApp = "${env.HEROKU_PRODUCTION}"
//     step([$class: 'ArtifactArchiver', artifacts: '**/target/*.jar', fingerprint: true])
//     deployToStage("production", herokuApp)
//     def version = getCurrentHerokuReleaseVersion("${env.HEROKU_PRODUCTION}")
//     def createdAt = getCurrentHerokuReleaseDate("${env.HEROKU_PRODUCTION}", version)
//     echo "Release version: ${version}"
//     createRelease(version, createdAt)
//
//     stage ("Promote in Artifactory") {
//         promoteBuildInArtifactory()
//         // distributeBuildToBinTray()
//     }
// }

// void createRelease(tagName, createdAt) {
//     withCredentials([[$class: 'StringBinding', credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN']]) {
//         def body = "**Created at:** ${createdAt}\n**Deployment job:** [${env.BUILD_NUMBER}](${env.BUILD_URL})\n**Environment:** [${env.HEROKU_PRODUCTION}](https://dashboard.heroku.com/apps/${env.HEROKU_PRODUCTION})"
//         def payload = groovy.json.JsonOutput.toJson(["tag_name": "v${tagName}", "name": "${env.HEROKU_PRODUCTION} - v${tagName}", "body": "${body}"])
//         def apiUrl = "https://octodemo.com/api/v3/repos/${getRepoSlug()}/releases"
//         def response = sh(returnStdout: true, script: "curl -s -H \"Authorization: Token ${env.GITHUB_TOKEN}\" -H \"Accept: application/json\" -H \"Content-type: application/json\" -X POST -d '${payload}' ${apiUrl}").trim()
//     }
// }
//
// def deployToStage(stageName, herokuApp) {
//     stage name: "Deploy to ${stageName}", concurrency: 1
//     id = createDeployment(getBranch(), "${stageName}", "Deploying branch to ${stageName}")
//     echo "Deployment ID for ${stageName}: ${id}"
//     if (id != null) {
//         setDeploymentStatus(id, "pending", "https://${herokuApp}.herokuapp.com/", "Pending deployment to ${stageName}");
//         herokuDeploy "${herokuApp}"
//         setDeploymentStatus(id, "success", "https://${herokuApp}.herokuapp.com/", "Successfully deployed to ${stageName}");
//     }
// }

// // Deploys core services to the current branch namespace using the given `agaveVersion` tag.
// def helmDeploy (agaveVersion) {
//     stage('Deploy core-services') {
//         def helmRelease = getCurrentHelmRelease()
//         withCredentials([file(credentialsId: 'agave-kubectl-config', variable: 'KUBECONFIG_FILE_PATH')]) {
//
//             if (helmRelease == null) {
//                 sh "helm3 --kubeconfig \"${env.KUBECONFIG_FILE_PATH}\" install --namespace ${env.BRANCH} --set agave.version=${agaveVersion} core-services agave/core-service'"
//             } else {
//                 sh "helm3 --kubeconfig \"${env.KUBECONFIG_FILE_PATH}\" upgrade --namespace ${env.BRANCH} --set agave.version=${agaveVersion} core-services agave/core-service'"
//             }
//         }
//     }
// }

//
//def switchSnapshotBuildToRelease() {
//    def descriptor = Artifactory.mavenDescriptor()
//    descriptor.version = '1.0.0'
//    descriptor.pomFile = 'pom.xml'
//    descriptor.transform()
//}
//
//def buildAndPublishToArtifactory() {
//        def rtMaven = Artifactory.newMavenBuild()
//        rtMaven.tool = null
//        withEnv(["MAVEN_HOME=/usr/share/maven"]) {
//           rtMaven.deployer releaseRepo:'libs-release-local', snapshotRepo:'libs-snapshot-local', server: server
//           rtMaven.resolver releaseRepo:'libs-release', snapshotRepo:'libs-snapshot', server: server
//           rtMaven.run pom: 'pom.xml', goals: 'install', buildInfo: buildInfo
//           server.publishBuildInfo buildInfo
//        }
//}
//
//def promoteBuildInArtifactory() {
//        def promotionConfig = [
//            // Mandatory parameters
//            'buildName'          : buildInfo.name,
//            'buildNumber'        : buildInfo.number,
//            'targetRepo'         : 'libs-prod-local',
//
//            // Optional parameters
//            'comment'            : 'deploying to production',
//            'sourceRepo'         : 'libs-release-local',
//            'status'             : 'Released',
//            'includeDependencies': false,
//            'copy'               : true,
//            // 'failFast' is true by default.
//            // Set it to false, if you don't want the promotion to abort upon receiving the first error.
//            'failFast'           : true
//        ]
//
//        // Promote build
//        server.promote promotionConfig
//}
//
//def distributeBuildToBinTray() {
//        def distributionConfig = [
//            // Mandatory parameters
//            'buildName'             : buildInfo.name,
//            'buildNumber'           : buildInfo.number,
//            'targetRepo'            : 'reading-time-dist',
//            // Optional parameters
//            //'publish'               : true, // Default: true. If true, artifacts are published when deployed to Bintray.
//            'overrideExistingFiles' : true, // Default: false. If true, Artifactory overwrites builds already existing in the target path in Bintray.
//            //'gpgPassphrase'         : 'passphrase', // If specified, Artifactory will GPG sign the build deployed to Bintray and apply the specified passphrase.
//            //'async'                 : false, // Default: false. If true, the build will be distributed asynchronously. Errors and warnings may be viewed in the Artifactory log.
//            //"sourceRepos"           : ["yum-local"], // An array of local repositories from which build artifacts should be collected.
//            //'dryRun'                : false, // Default: false. If true, distribution is only simulated. No files are actually moved.
//        ]
//        server.distribute distributionConfig
//}

//def mvn(args) {
//    withMaven(
//        // mavenSettingsConfig: '0e94d6c3-b431-434f-a201-7d7cda7180cb'
//
//        //mavenLocalRepo: '/tmp/m2'
//        ) {
//
//      // Run the maven build
//      sh "mvn $args -Dmaven.test.failure.ignore -Dmaven.repo.local=/cache"
//     }
//}

def getRepoSlug() {
    tokens = "${env.JOB_NAME}".tokenize('/')
    org = tokens[tokens.size()-3]
    repo = tokens[tokens.size()-2]
    return "${org}/${repo}"
}




// update helm chart with latest release
def updateHelmChart(ref, environment, description) {
    stage('Update Helm Chart') {
    	withCredentials([
    			[$class: 'StringBinding', credentialsId: 'HELM_REPO_USERNAME', variable: 'HELM_REPO_USERNAME'],
    			[$class: 'StringBinding', credentialsId: 'HELM_REPO_PASSWORD', variable: 'HELM_REPO_PASSWORD']]) {
    		step: "Package chart"
    			def packagedChartPath = sh(returnStdout: true, script: 'helm3 package charts/core-services | sed -E "s/.*\\:(.*)/\\1/"').trim()
    		step: "Push chart to chartmuseum"
    			sh "curl -u '${env.HELM_REPO_USERNAME}:${env.HELM_REPO_PASSWORD}' -XPOST https://helm.agaveplatform.org/api/charts --data-binary @${packagedChartPath}"
    	}
    }
}

// Deploy updated chart
def createDeployment(ref, environment, description) {
    withCredentials([[$class: 'StringBinding', credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN']]) {
            def payload = groovy.json.JsonOutput.toJson(["ref": "${ref}", "description": "${description}", "environment": "${environment}", "required_contexts": []])
        def apiUrl = "https://octodemo.com/api/v3/repos/${getRepoSlug()}/deployments"
        def response = sh(returnStdout: true, script: "curl -s -H \"Authorization: Token ${env.GITHUB_TOKEN}\" -H \"Accept: application/json\" -H \"Content-type: application/json\" -X POST -d '${payload}' ${apiUrl}").trim()
        def jsonSlurper = new groovy.json.JsonSlurper()
        def data = jsonSlurper.parseText("${response}")
        return data.id
    }
}

// // Update github deployment status
// void setDeploymentStatus(deploymentId, state, targetUrl, description) {
//     withCredentials([[$class: 'StringBinding', credentialsId: 'GITHUB_TOKEN', variable: 'GITHUB_TOKEN']]) {
//         def payload = groovy.json.JsonOutput.toJson(["state": "${state}", "target_url": "${targetUrl}", "description": "${description}"])
//         def apiUrl = "https://octodemo.com/api/v3/repos/${getRepoSlug()}/deployments/${deploymentId}/statuses"
//         def response = sh(returnStdout: true, script: "curl -s -H \"Authorization: Token ${env.GITHUB_TOKEN}\" -H \"Accept: application/json\" -H \"Content-type: application/json\" -X POST -d '${payload}' ${apiUrl}").trim()
//     }
// }

// Update github build status
void setGithubBuildStatus(context, message, state) {
  step([
      $class: "GitHubCommitStatusSetter",
      contextSource: [$class: "ManuallyEnteredCommitContextSource", context: context],
      errorHandlers: [[$class: "ChangingBuildStatusErrorHandler", result: "UNSTABLE"]],
      reposSource: [$class: "ManuallyEnteredRepositorySource", url: "https://github.com/agaveplatform/science-apis"],
      statusResultSource: [ $class: "ConditionalStatusResultSource", results: [[$class: "AnyBuildResult", message: message, state: state]] ]
  ]);
}

// Fetches the current helm chart release version from the kubernetes server
def getCurrentHelmRelease(app) {
	withCredentials([file(credentialsId: 'agave-kubectl-config', variable: 'KUBECONFIG_FILE_PATH')]) {
        def response = sh(returnStdout: true, script: "helm3 --kubeconfig \"${env.KUBECONFIG_FILE_PATH}\" list --namespace ${environment} --filter 'agave-core' -o json").trim()
        if (response != null || response != '[]') {
            def jsonSlurper = new groovy.json.JsonSlurper()
            def data = jsonSlurper.parseText("${response}")
            return data[0]
        } else {
            return null
        }
    }
}











